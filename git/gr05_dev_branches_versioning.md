# Git Rule 05: Версионирование в ветках dev

## [1] Схема версионирования в ветках dev

Зафиксированная версия в ветке dev  (см. ниже определение) любого репозитория выглядит следующим образом:

```
V.dev.N
```

где

- `V` - это версия релиза, после которого идёт работа в ветке dev. Например `2.21.0`.
- `dev` - это константа, показывающая, что версия является версией в ветке dev.
- `N` - это целое число, инкрементируемое каждый раз при фиксации версии, когда в ветку dev сливается очередная задача. Например, `2`.

Всё вместе, например, `2.21.0.dev.2`.

Зафиксированная версия в ветке dev - это версия, которая выставляется либо после слития релиза, либо после слития очередной задачи по следующим правилам:

- В случае слития в ветку dev выпущенного релиза части версии меняются следующим образом:
    - `V` - меняется на версию релиза
    - `N` - становится равным `0`
    - Например, версия в ветке dev до слития релиза была `2.21.0.dev.15`, а после слития релиза и фиксации версии стала `2.22.0.dev.0`
- В случае слития в ветку dev очередной задачи части версии меняются следующим образом:
    - `N` - увеличивается на 1
    - Например, версия в ветке dev до слития очередной задачи была `2.21.0.dev.15`, а после слития очередной задачи и фиксации версии стала `2.21.0.dev.16`

Фиксация версии в ветке dev - это коммит в ветке dev, который изменяет версию согласно правилам слития веток в ветку dev, описанным выше, и добавление тега со значением версии на этот коммит.

## [2] Версия задачи

После создания ветки для задачи от ветки dev первым делом формируется версия задачи (`TODO ссылка на доработанное правило GR01`). Для формирования версии задачи нужно к dev-версии через символ `.` добавить ключ задачи, а в случае с jar-библиотеками добавить ещё `-SNAPSHOT`.

Пример версий для задачных веток:

- Такая версия будет у репозиториев, не являющихся jar-библиотеками:
  
  `2.22.0.dev.1` - dev-версия
  
  `2.22.0.dev.1.{{JIRA-PROJECT-KEY}}-{{JIRA-ISSUE-NUMBER}}` - версия задачи в общем случае
  
  `2.22.0.dev.1.HRL-125` - версия задачи `HRL-125` для проекта HR-Link
- Такая версия будет у репозиториев, являющихся jar-библиотеками:
  
  `2.22.0.dev.1` - dev-версия
  
  `2.22.0.dev.1.{{JIRA-PROJECT-KEY}}-{{JIRA-ISSUE-NUMBER}}-SNAPSHOT` - версия задачи в общем случае
  
  `2.22.0.dev.1.HRL-125-SNAPSHOT` - версия задачи `HRL-125` для проекта HR-Link

## [3] Схемы слития веток в ветку dev

#### [3.0] Предварительные условия

**Важно**, чтобы перед тем, как выполнять слитие чего-либо в ветку dev, необходимо, чтобы в папке репозитория отсутствовали незакоммиченные изменения. Если это не так, то предварительно необходимо закоммитить изменения или спрятать их. Если изменений нет, то переключится на ветку задачи и подтянуть последние изменения, переключится на ветку dev и подтянуть последние изменения:

```
$ git status
...
nothing to commit, working tree clean
$ git fetch
$ git checkout {{ISSUE_BRANCH_NAME}}
$ git pull
$ git checkout dev
$ git pull
```

#### [3.1] Варианты слития ветки задачи в ветку dev без учёта зависимости

Сначала рассмотрим слитие ветки задачи в ветку dev без учёта того, что между репозиториями возможны зависимости (например между репозиторием сервиса и репозиторием jar-библиотеки, от которой этот сервис зависит).

**3.1.1.)** Ветка задачи была сделана от ветки dev и после этого в ветку dev ничего не сливалось:

```
                             V.dev.N.X
                  [branch X] ----*----
                            /   [2]   \
               V.dev.N     /           \ [3]             [4]
[branch dev] -----*-------/-------------*-----------------*---------
                 [1]                 V.dev.N.X       V.dev.{{N+1}}
```

- [1] Фиксация версии в ветке dev после слития релиза или очередной задачи.
- [2] Версия задачи в ветке задачи.
- [3] При слитии ветки задачи в ветку dev версия в ветке dev автоматически без конфликтов станет равной версии в ветке задаче.
- [4] При фиксации версии в ветке dev после слития очередной задачи инкрементальная часть версии увеличивается на 1, суффикс задачи отбрасывается.

**3.1.2.)** Ветка задачи была сделана от ветки dev и после этого в ветку dev выполнялись слития. В этом случае возможны два варианта, которые в целом никак не влияют на логику слития ветки задачи в ветку dev:

- В ветку dev выполнялись слития, при этом версия последнего релиза осталась такой же, как и в задаче.
- В ветку dev выполнялись слития, при этом версия последнего релиза изменилась относительно версии релиза в задаче.

```
                                          Версия релиза в ветке dev и ветке задачи РАВНЫ
                                          В этом случае обязательно выполняется условие, что N < M
              V.dev.N.X
  [branch X] -----*------------
                 [1]           \
                     V.dev.M    \ [3]          [4]
[branch dev] ----------*---------*--------------*---------
                      [2]     V.dev.M.X     V.dev.{{M+1}}
```

```
                                          Версия релиза в ветке dev и ветке задачи НЕ РАВНЫ
                                          В этом случае отношение между N и M неизвестно
              V1.dev.N.X
  [branch X] ------*-----------
                  [1]          \
                    V2.dev.M    \ [3]          [4]
[branch dev] ----------*---------*--------------*---------
                      [2]    V2.dev.M.X    V2.dev.{{M+1}}
```

- [1] Версия задачи.
- [2] Фиксация версии в ветке dev после слития релиза или очередной задачи.
- [3] При слитии ветки задачи в ветку dev будет конфликт версии. При слитии нужно сформировать версию следующим образом:
    - Версия релиза берётся из ветки dev
    - Инкрементальная часть берётся из ветки dev
    - К этому добавляется суффикс задачи (ключ задачи + `-SNAPSHOT` для jar-библиотек)
    - По сути это всё равно что сначала слить актуальное состояние ветки dev в ветку задачи, после чего слить ветку задачи в dev.
- [4] При фиксации версии в ветке dev после слития очередной задачи инкрементальная часть версии увеличивается на 1, суффикс задачи отбрасывается.

#### [3.2] Варианты слития ветки задачи в ветку dev при наличии зависимости

Теперь рассмотрим варианты слития веток в ветку dev для сервиса, который имеет зависимость от jar-библиотеки. В этом случае работает  следующее правило:

- при наличии зависимости сервиса от jar-библиотеки при фиксации версии сервиса в ветке dev версия jar-библиотеки **всегда  должна быть зафиксированной версией jar-библиотеки**.

Например:

- Сервис с версией `2.20.0.dev.1` в ветке dev зависит от jar-библиотеки с версией `1.12.0.dev.0`.
- Сервис с версией `2.20.0.dev.23` в ветке dev зависит от jar-библиотеки с версией `1.12.0.dev.11`.

Таким образом в момент фиксации версии сервиса в ветке dev получается неизменяемое состояние сервиса и его зависимостей, что даёт возможность в любой момент переключится на нужные версии компонентов и собрать их для проверки.

**Внимание**. На всех схемах ниже указывается только версия jar-библиотеки, от которой зависит сервис. Для изменения версии сервиса при слитии веток в ветку dev необходимо руководствоваться правилами, описанными в [3.1].

**3.2.1.)** При решении задачи ветки в репозитории jar-библиотеки не создавалось, при этом версия jar-библиотеки в ветке dev и в ветке задачи всё ещё одинаковые на момент слития:

```
                              V.dev.N
                  [branch X] ----*----
                            /   [2]   \
               V.dev.N     /           \ [3]             [4]
[branch dev] -----*-------/-------------*-----------------*---------
                 [1]                  V.dev.N           V.dev.N
```

- [1] Фиксация версии в ветке dev после слития релиза или очередной задачи, в которой версия зависимости от jar-библиотеки была установлена как `V.dev.N`.
- [2] Версия задачи, в которой версия зависимости от jar-библиотеки не изменялась.
- [3] При слитии ветки задачи в ветку dev версия зависимости от jar-библиотеки не изменится и останется прежней.
- [4] При фиксации версии в ветке dev после слития очередной задачи версия зависимости от jar-библиотеки не изменится и останется прежней.

**3.2.2.)** При решении задачи ветки в репозитории jar-библиотеки не создавалось, при этом версия jar-библиотеки в ветке dev изменилась относительно версии jar-библиотеки в ветке задачи:

```
                           Версия релиза зависимости от jar-бибилиотеки в ветке dev и ветке задачи РАВНЫ
                           В этом случае обязательно выполняется условие, что N < M
              V.dev.N
  [branch X] ----*-------------
                [1]            \
                   V.dev.M      \ [3]          [4]
[branch dev] ---------*----------*--------------*---------
                     [2]      V.dev.M        V.dev.M
```

```
                           Версия релиза зависимости от jar-бибилиотеки в ветке dev и ветке задачи НЕ РАВНЫ
                           В этом случае отношение между N и M неизвестно
              V1.dev.N
  [branch X] ----*-------------
                [1]            \
                   V2.dev.M     \ [3]          [4]
[branch dev] ---------*----------*--------------*---------
                     [2]      V2.dev.M        V2.dev.M
```

- [1] Версия задачи, в которой версия зависимости от jar-библиотеки не изменялась.
- [2] Фиксация версии в ветке dev после слития релиза или очередной задачи, в которой версия зависимости от jar-библиотеки изменилась относительно ветки задачи.
- [3] При слитии ветки задачи в ветку dev версия зависимости от jar-библиотеки останется такой, какой она была в ветке dev.
- [4] При фиксации версии в ветке dev после слития очередной задачи версия зависимости от jar-библиотеки не изменится и останется прежней.

**3.2.3.)** При решении задачи ветка в репозитории jar-библиотеки создавалась, при этом версия релиза и инкрементальная часть версии jar-библиотеки в ветке dev и в ветке задачи всё ещё одинаковые на момент слития:

```
                             V.dev.N.X
                  [branch X] ----*----
                            /   [2]   \
               V.dev.N     /           \ [3]             [4]
[branch dev] -----*-------/-------------*-----------------*---------
                 [1]                V.dev.N.X         V.dev.{{N+1}}
```

- [1] Фиксация версии в ветке dev после слития релиза или очередной задачи, в которой версия зависимости от jar-библиотеки была установлена как `V.dev.N`.
- [2] Версия задачи, в которой версия зависимости от jar-библиотеки была установлена равной версии в ветке задачи для jar-библиотеки.
- В качестве предварительного шага слития ветки задачи в ветку dev для сервиса должно быть выполнено слитие ветки задачи в ветку dev для jar-библиотеки, и получена зафиксированная версия jar-библиотеки в ветке dev. Предположим, что получившаяся зафиксированная версия jar-библиотеки в ветке dev  `V'.dev.M`.
- Перед тем как выполнять слитие ветки задачи в ветку dev для сервиса необходимо проверить определённые отношения между версией зависимости от jar-библиотеки в ветке dev и зафиксированной версией jar-библиотеки в ветке dev:
    - Версии релизов должны совпадать (в нашем примере это `V` == `V'`).
    - Инкрементальная часть версии в ветке dev должна быть на один меньше инкрементальной части в зафиксированной версии jar-библиотеки в ветке dev (в нашем примере это `N + 1` == `M`).
- **Важно.** Если условия выше не выполняются, значит кто-то другой тоже выполняет слитие веток в ветки dev. В таком случае нужно дождаться, когда этот человек закончит своё слитие в ветку dev сервиса, после чего условия по сравнению версий зависимости от jar-библиотеки должны начать выполняться. Но в таком случае схема слития уже будет такой, какая описана в разделе [3.2.4].
- [3] При слитии ветки задачи в ветку dev версия зависимости от jar-библиотеки автоматически без конфликтов станет равной версии в ветке задаче.
- [4] При фиксации версии в ветке dev после слития очередной задачи инкрементальная часть версии зависимости от jar-библиотеки увеличивается на 1, суффикс задачи отбрасывается.

**3.2.4.)** При решении задачи ветка в репозитории jar-библиотеки создавалась, при этом версия jar-библиотеки в ветке dev изменилась относительно первоначальной версии jar-библиотеки в ветке задачи:

```
                             Версия релиза зависимости от jar-бибилиотеки в ветке dev и ветке задачи РАВНЫ
                             В этом случае обязательно выполняется условие, что N < M
              V.dev.N.X
  [branch X] ----*-------------
                [1]            \
                   V.dev.M      \ [3]          [4]
[branch dev] ---------*----------*--------------*---------
                     [2]     V.dev.{{M+1}}  V.dev.{{M+1}}
```

```
                           Версия релиза зависимости от jar-бибилиотеки в ветке dev и ветке задачи НЕ РАВНЫ
                           В этом случае отношение между N и M неизвестно
              V1.dev.N.X
  [branch X] ----*-------------
                [1]            \
                   V2.dev.M     \ [3]          [4]
[branch dev] ---------*----------*--------------*---------
                     [2]    V2.dev.{{M+1}}  V2.dev.{{M+1}}
```

- [1] Версия задачи, в которой версия зависимости от jar-библиотеки была установлена равной версии в ветке задачи для jar-библиотеки.
- [2] Фиксация версии в ветке dev после слития релиза или очередной задачи, в которой версия зависимости от jar-библиотеки изменилась относительно ветки задачи.
- В качестве предварительного шага слития ветки задачи в ветку dev для сервиса должно быть выполнено слитие ветки задачи в ветку dev для jar-библиотеки, и получена зафиксированная версия jar-библиотеки в ветке dev. Предположим, что получившаяся зафиксированная версия jar-библиотеки в ветке dev  `V'.dev.P`.
- Перед тем как выполнять слитие ветки задачи в ветку dev для сервиса необходимо проверить определённые отношения между версией зависимости от jar-библиотеки в ветке dev и зафиксированной версией jar-библиотеки в ветке dev:
    - Версии релизов должны совпадать (в наших примерах это `V` == `V'` или `V2` == `V'`).
    - Инкрементальная часть версии в ветке dev должна быть на один меньше инкрементальной части в зафиксированной версии jar-библиотеки в ветке dev (в наших примерах это `M + 1` == `P`).
- **Важно.** Если условия выше не выполняются, значит кто-то другой тоже выполняет слитие веток в ветки dev. В таком случае нужно дождаться, когда этот человек закончит своё слитие в ветку dev сервиса, после чего условия по сравнению версий зависимости от jar-библиотеки должны начать выполняться.
- [3] При слитии ветки задачи в ветку dev версия зависимости от jar-библиотеки покажет конфликт. При разрешении этого конфликта должна быть указана версия зависимости от jar-библиотеки, которая была получена после слития и фиксации версии ветки задачи для jar-библиотеки `V'.dev.P`.
- [4] При фиксации версии в ветке dev после слития очередной задачи версия зависимости от jar-библиотеки останется такой же, какой была указана при разрешении конфликта.

## [4] Выполнение слития в ветку dev и фиксация версии

Порядок слития веток задачи в ветки dev:

1. Открыть канал для уведомлений о слитии веток задач в ветки dev и убедиться, что никто сейчас не выполняет слитий.

    - Если кто-то сейчас выполняет слития, то написать сообщение, что после завершения слитий этим человеком вы хотите выполнять слития. Тем самым вы как бы занимаете очередь для слития веток задач в ветки dev

    - Если кто-то сейчас выполняет слития, то дождитесь, когда этот человек закончит.

2. Если никто слитий не выполняет, или вы дождались окончания работы предыдущего человека, то написать в канал, что вы приступаете к слитию веток задач в ветки dev.

    - Для удобства остальных участников будет хорошо, если вы дадите ссылку на задачу или задачи, которые вы будете сливать в ветки dev.

3. **Слития в ветки dev нужно делать по задачам.** Нельзя сливать в ветку dev сразу несколько веток разных задач. Сначала по всем репозитория сливаются ветки одной задачи, затем по всем репозиториям сливаются ветки следующей задачи.

4. Для выбранной задачи нужно определить репозитории, для которых будет выполняться слитие веток задачи в ветки dev, и зависимости между этими репозиториями. Зависимости между репозиториями дадут понимание порядка слития по репозиториям. Начинать нужно с репозитория, независящего ни от кого, и продвигаться к репозиторию, зависящему от всех остальных.

5. Для очередного репозитория, в котором будет производиться слитие, нужно убедиться, что нет незакоммиченных изменений:

   ````
   $ git status
   ...
   nothing to commit, working tree clean
   ````

   Если изменения есть, то необходимо их закоммитить или спрятать.

6. Подтянуть последние изменения для ветки задачи и ветки dev:

   ```
   $ git fetch
   $ git checkout {{ISSUE_BRANCH_NAME}}
   $ git pull
   $ git checkout dev
   $ git pull
   ```

7. Выполнить слитие ветки задачи в ветку dev согласно правилам, описанным в разделе [3]:

   ```
   $ git branch --show-current
   dev
   $ git merge {{ISSUE_BRANCH_NAME}}
   ```

    - Для слития ветки задачи в очередном репозитории вам могут потребоваться получившиеся зафиксированные версии в ветках dev при слитиях в предыдущих репозиториях.
    - При выполнении слития нужно добиться того, чтобы проект компилировался. При этом следует руководствоваться следующими соображениями:
        - Если изменения для корректной компиляции небольшие, то их можно сделать сразу в рамках слития.
        - Если изменения для корректной компиляции большие, то лучше их сделать отдельными коммитами после слития.
        - Если слитие происходит автоматически, и после этого проект не компилируется, то изменения для корректной компиляции точно будут отдельными коммитами.

8. Выполнить фиксацию версии в dev ветке:

    1. Изменить версию согласно правилам, описанным в разделе [3].

        - **Заметка**. Для разных проектов версия меняется в соответствующих файлах.

    2. Изменить версии зависимостей, если это необходимо, согласно правилам, описанным в разделе [3].

    3. Закоммитить изменения версий, где вместо `{{NEW_DEV_VERSION}}` подставить версию, которая получилась в пункте 7.1:

       ```
       $ git commit -q -m "{{NEW_DEV_VERSION}}"
       ```

    4. Добавить тег на коммит с изменениями версии, где вместо `{{NEW_DEV_VERSION}}` подставить версию, которая получилась в пункте 7.1:

       ```
       $ git tag -a "{{NEW_DEV_VERSION}}" HEAD -m "{{NEW_DEV_VERSION}}"
       ```

9. Запушить изменения:

   ```
   $ git push
   ```

10. Если ещё есть репозитории, в которых необходимо выполнить слитие, то перейти снова к пункту 4. Если слития выполнены во всех репозиториях, то перейти дальше.

11. Написать в канал для уведомлений о слитии веток задач в ветки dev о том, что вы закончили слитие.

## [5] Возможные проблемы и как их избежать

Все возможные проблемы процесса слития веток в ветки dev связаны с параллельной нескоординированной работой двух или более человек. Поэтому основное решение всех проблем:

- Смотреть в канал уведомлений о выполняющихся в данный момент слитиях в ветки dev
- Уведомлять о желании выполнить слития в ветки dev
- Уведомлять о начале выполнения слитий в ветки dev
- Уведомлять о завершении слитий в ветки dev

Тем не менее мы все можем это забыть и попасть в одну из проблемных ситуаций. Поэтому далее рассмотрим каждую проблему и как из неё выходить.

#### [5.1] Создание веток в зависимых репозиториях при выполнении слитий в этот же момент

**Сценарий:** Для очередной задачи вы создали ветку для сервиса. В получившейся ветке он зависит от jar-библиотеки с версией `V.dev.N`. В это время кто-то производил слитие и создал очередную версию jar-библиотеки `V.dev.{{N+1}}` в ветке dev. Вы создаёте ветку для jar-библиотеки уже от версии `V.dev.{{N+1}}`. При создании веток в обратном порядке ситуация всё так же может произойти, если в ветку dev jar-библиотеки уже что-то было слито с увеличением dev-версии, а в ветку dev сервиса слитие ещё не было произведено.

**Проблема:** Если после этого в задачной ветке сервиса сделать зависимость от задачной ветки jar-библиотеки, то могут быть проблемы, что сервис не будет компилироваться, т.к. в нём ещё нет необходимых изменений.

**Как избежать:**

- Проверить канал для уведомлений о выполнении слитий в ветки dev. Если выполняются слития, то дождаться их окончания перед тем как создавать ветки.

- Если ждать не хочется, то можно создать ветку для сервиса, а ветку для jar-библиотеки создавать локально через переключение на коммит по тегу версии:

  ```
  $ git checkout tags/{{DESIRED_DEV_VERSION}}
  $ git checkout -b {{ISSUE_BRANCH_NAME}}
  ```

**Что делать, если произошла:**

- Или дождаться слития в ветку dev для сервиса и слить эти изменения в ветку задачи.
- Или пересоздать ветку для jar-библиотеки через ручное переключение на коммит по тегу версии.

**Рекомендация:** Предполагается, что данная ситуация должна происходить редко. Можно продолжать создавать ветки через UI Jira + Bitbucket. Но перед началом написания кода необходимо убедиться, что версия релиза и инкрементальная часть версии зависимости от jar-библиотеки одинаковые в ветке задачи сервиса и в ветке задачи jar-библиотеки. Если это не так, то смотри "Что делать, если произошла".

#### [5.2] Параллельное слитие веток в зависимые репозитории

**Сценарий:** При выполнении слития, описанного в разделе [4], при выполнении `git push` возвращается ошибка, что история ветки на удалённом сервере уже изменилась. Это может произойти если два человека параллельно сливают в ветку dev в одном репозитории. Кто-то из них успеет запушить первый, а у второго будет ошибка.

**Проблема:** Состояние локальной ветки того человека, который не успел запушить будет некорректное. Такое состояние нельзя пушить, нельзя просто последние подтянуть изменения и запушить.

**Как избежать:** Проверить канал для уведомлений о выполнении слитий в ветки dev. Если выполняются слития, то заявить о том, что вы хотите сливать в ветки dev после окончания работы другого человека, дождаться окончания слитий другим человеком, после чего начать слития самому.

**Что делать, если произошла:**

- Необходимо удалить созданный тег и удалить коммит с изменением версии:

  ```
  $ git reset --hard HEAD~1
  $ git tag -d "{{NEW_DEV_VERSION}}"
  ```

- Подтянуть последние изменения в ветке dev:

  ```
  $ git pull
  ```

  В этом случае

- Зафиксировать новую версию в ветке dev.

- Запушить изменения:

  ```
  $ git push
  ```

#### [5.3] Deadlock при параллельном слитии веток в зависимые репозитории

**Сценарий:** Возможна ситуация deadlock'а, если есть сервис, зависящий от двух jar-библиотек, и есть два человека, которые сделали изменения и в сервисе, и в обеих библиотеках. Если один человек успел первым зафиксировать версию в ветке dev для первой jar-библиотеки, а другой человек успел первым зафиксировать версию в ветке dev для второй jar-библиотеки, то в итоге ни у кого из них не выполнятся условия проверки перед слитием ветки задачи в ветку dev для сервиса.

**Проблема:** Оба человека решат, что нужно ждать, и слитие веток заблокируется.

**Как избежать:** Проверить канал для уведомлений о выполнении слитий в ветки dev. Если выполняются слития, то заявить о том, что вы хотите сливать в ветки dev после окончания работы другого человека, дождаться окончания слитий другим человеком, после чего начать слития самому.

**Что делать, если произошла:**

- TODO Требует проработки

## [6] Автоматизация при работе с ветками dev

#### [6.1] Скрипт автоматического создания веток для зависимых репозиториев

TODO Требует проработки

- Чтобы быстро и удобно создать ветку сразу и для сервиса и для jar-библиотеки с автоматической проверкой, что версия jar-библиотеки и там, и там одна и та же. Если же версия получается разная, то сразу получить предупреждение об этом.

#### [6.2] Скрипт автоматического слития в ветку dev

TODO Требует проработки

- Принимает два параметра: ветку для слития в dev, зафиксированную версию зависимости, если она есть.
- Проверяет, что запускается из нужной папки, что есть корневой файл сборки для соответствующего проекта.
- Проверяет, что нет незакоммиченных изменений.
- Пропуливает ветки.
- Выполняет merge.
- Если merge автоматический, то выполняет компиляцию. Если есть конфликты, то говорит иди решай.
- Выполняет компиляцию ok. Если компиляция не ок, то говорит: "иди чини".
- Проверяет версию зависимости, если она задана. Проверяет, что она нужна была, но не была задана.
- Если всё ок, то автоматически изменяет версию согласно правилам, добавляет тег.
- Скрипт должно быть можно запускать несколько раз после исправления конфликтов и компиляции.

#### [6.3] Скрипт автоматической фиксации версии в ветке dev

TODO Требует проработки

- По сути является частью скрипта [6.2], когда удобнее просто вызвать логику изменения версии.
- Принимает параметр с версией зависимости, если она есть.
- Проверяет, что запускается из нужной папки, что есть корневой файл сборки для соответствующего проекта.
- Проверяет, что нет незакоммиченных изменений.
- Пропуливает dev.
- Извлекает части версии, валидирует, что всё получается.
- Проверяет корректность версии зависимости.
- Изменяет версии.
- Выполняет коммит изменений.
- Создаёт тег.

#### [6.4] Скрипт автоматического отката фиксации версии в ветке dev

TODO Требует проработки

- Чтобы было удобно откатить фиксацию, если не удался пуш в п.8 раздела [4].
- Удаляет локальный тег.
- Уничтожает коммит с изменением версии.
