## Angular Rule: Action'ы в Angular проекте



Правила создания action'ов в Angular проекте. На момент написания у нас есть проекты на 7й версии и на 8й версии ngrx/store. В 8й версии доступны инструменты для reducer'ов, которые немного упрощают работу с action'ами.



### 7ая версия ngrx/store

1. Для группы action'ов создаётся ts-файл some.actions.ts в папке store/actions.

2. Создаём и **экспортируем** enum с перечислением типов action'ов.
   \- Тип не должен включать в себя имя enum'а.

   ```
   /**
    * Типы событий, связанные с ... .
    */
   export enum SomeActionType {
       //region Enum values
   
       /**
        * Тип события, требующий инициализации ... .
        */
       INIT = "[Some actions group] Init",
       
       /*
        * Тип события, требующий открытия ... .
        */
       OPEN = "[Some actions group] Open",
       
       //endregion
   };
   ```

3. Для данных, которые будут переносит планируемые к созданию action'ы, нужно создать интерфейсы в папке store/actions/props. Имя ts-файла должно быть по форме some-data.action-props.ts.

4. Создаём action с помощью фабричной функции createAction из @ngrx/store
   \- В качестве типа указываем соответствующее значение из enum'а, созданного на шаге 2.
   \- Имя action'а совпадает с его типом из enum'а, т.е. тоже является коротким и не включает в себя имя группы action'ов.
   \- Если action несёт с собой какие-то данные, то нужно использовать функцию props из @ngrx/store.
   \- **Не экспортируем** созданный action.

   ```
   /**
    * Событие, требущее инициализации ... .
    */
   const init = createAction(
       SomeActionType.INIT,
       props<SomeActionInitProps>(),
   );
   
   /**
    * Событие, требущее открытия ... .
    */
   const open = createAction(
       SomeActionType.OPEN,
   );
   ```

   По факту получается функция для создания экземпляров action'ов, которая не принимает ничего, если props не использовалась, либо принимает экземпляр указанного в props интерфейса.

5. В конце файла создаём объединённый тип для всех action'ов

   ```
   /**
    * Тип, объединяющий все события, связанные с ... .
    */
   export type SomeAction =
       | ReturnType<typeof init>
       | ReturnType<typeof open>;
   ```

   Данный подход работает при смешивании старых action'ов, которые сделаны через class, и новых action'ов, которые сделаны с помощью фабричной функции createAction.

6. В конце файла создаём и экспортируем объект-контейнер, который содержит в себе все action'ы

   ```
   /**
    * Все события ... .
    */
   export const SomeActions = {
       init,
       open,
   };
   ```



### 8ая версия ngrx/store

TODO



### Использование

В итоге получаем, что при использовании action'ов нужно будет импортировать объект-контейнер и в его контексте вызывать функции для создания экземпляров action'ов.

```
import { SomeActions } from "src/modules/root/store/actions/some.actions.ts"

...
    this._store.dispatch(SomeActions.init(props));
...
```



### PascalCase именование объекта-контейнера

Объект-контейнер, который содержит в себе функции для создания экземпляров action'ов, имеет имя, начинающееся в заглавной буквы. За это будет ругать TSLint. Поэтому нужно проверить, что в tslint.jsonправило variable-name настроено следующим образом:

```
"variable-name": {
    "options": [
        ...,
        "allow-pascal-case",
        ...
    ]
},
```

